# Задачи для финальной проверки знаний

## Тема 1: Сортировки

### Задача 1.1: Сортировка по последней цифре
Дан массив целых чисел. Отсортируйте его по возрастанию последней цифры числа. Если последние цифры равны, сохраните исходный порядок.

**Формат ввода:**
- Первая строка: N (количество чисел, 1 ≤ N ≤ 1000)
- Вторая строка: N целых чисел

**Формат вывода:**
Отсортированный массив

**Пример:**
```
Ввод:
5
12 34 23 45 11
Вывод:
11 12 23 34 45
```

**Вопросы для проверки:**
1. Какую сортировку вы использовали и почему?
2. Какова временная сложность вашего решения?
3. Можно ли решить эту задачу за O(n) времени? Почему да/нет?
4. Что произойдет, если использовать быструю сортировку без учета стабильности?

**Ответы на вопросы:**
1. Рекомендуется использовать стабильную сортировку (например, merge sort или сортировку с кастомным компаратором). Стабильность важна, так как при равных последних цифрах нужно сохранить исходный порядок.
2. Временная сложность O(n log n) при использовании merge sort или встроенной сортировки с компаратором.
3. Теоретически можно использовать counting sort по последней цифре (10 возможных значений), что даст O(n + k), где k = 10. Но на практике для небольших массивов разница незначительна.
4. При использовании нестабильной быстрой сортировки элементы с одинаковой последней цифрой могут поменяться местами, что нарушит требование сохранения исходного порядка.

**Пример решения:**
```python
n = int(input())
arr = list(map(int, input().split()))

# Используем встроенную сортировку с кастомным ключом
# key функция возвращает последнюю цифру, что обеспечивает стабильность
arr.sort(key=lambda x: x % 10)

print(' '.join(map(str, arr)))
```

---

### Задача 1.2: Сортировка четных и нечетных
Дан массив целых чисел. Отсортируйте массив так, чтобы сначала шли все четные числа по возрастанию, затем все нечетные по убыванию.

**Формат ввода:**
- Первая строка: N (1 ≤ N ≤ 1000)
- Вторая строка: N целых чисел

**Формат вывода:**
Отсортированный массив

**Пример:**
```
Ввод:
6
3 2 5 4 1 6
Вывод:
2 4 6 5 3 1
```

**Вопросы для проверки:**
1. Можно ли решить эту задачу одним проходом сортировки?
2. Какова сложность вашего алгоритма?
3. Как бы вы модифицировали merge sort для этой задачи?
4. В чем разница между вашим решением и использованием двух отдельных массивов?

**Ответы на вопросы:**
1. Да, можно использовать один проход сортировки с кастомным компаратором, который сначала сравнивает четность, а затем значения.
2. Сложность O(n log n) - стандартная сложность сортировки.
3. В merge sort нужно модифицировать функцию сравнения: сначала проверять четность (четные < нечетные), затем для четных сравнивать по возрастанию, для нечетных - по убыванию.
4. Разделение на два массива и их отдельная сортировка также дает O(n log n), но требует дополнительной памяти O(n). Единая сортировка с компаратором более элегантна и использует меньше памяти.

**Пример решения:**
```python
n = int(input())
arr = list(map(int, input().split()))

def compare(x, y):
    # Четные идут перед нечетными
    if x % 2 != y % 2:
        return -1 if x % 2 == 0 else 1
    # Если оба четные - по возрастанию
    if x % 2 == 0:
        return x - y
    # Если оба нечетные - по убыванию
    return y - x

# Используем встроенную сортировку с кастомным компаратором
arr.sort(key=lambda x: (x % 2, x if x % 2 == 0 else -x))

print(' '.join(map(str, arr)))
```

---

### Задача 1.3: Проверка отсортированности
Напишите функцию, которая проверяет, отсортирован ли массив по возрастанию. Если нет, верните индекс первого элемента, нарушающего порядок.

**Формат ввода:**
- Первая строка: N (1 ≤ N ≤ 1000)
- Вторая строка: N целых чисел

**Формат вывода:**
- Если массив отсортирован: "YES"
- Если нет: "NO" и индекс первого нарушения

**Пример:**
```
Ввод:
5
1 2 3 4 5
Вывод:
YES

Ввод:
5
1 3 2 4 5
Вывод:
NO 2
```

**Вопросы для проверки:**
1. Какова временная сложность вашего решения?
2. Можно ли решить эту задачу быстрее, чем O(n)?
3. Как бы вы модифицировали решение для проверки убывающего порядка?
4. Что произойдет, если массив содержит одинаковые элементы?

**Ответы на вопросы:**
1. Временная сложность O(n) - нужно пройти по массиву один раз, сравнивая соседние элементы.
2. Нет, нельзя решить быстрее O(n), так как нужно проверить все элементы для гарантии отсортированности. В худшем случае нарушение может быть в конце.
3. Для убывающего порядка нужно изменить условие сравнения: проверять arr[i] >= arr[i+1] вместо arr[i] <= arr[i+1].
4. Если массив содержит одинаковые элементы и мы проверяем строгое возрастание, то одинаковые элементы считаются нарушением. Если проверяем неубывание (нестрогое), то одинаковые элементы допустимы.

**Пример решения:**
```python
n = int(input())
arr = list(map(int, input().split()))

is_sorted = True
first_violation = -1

for i in range(n - 1):
    if arr[i] > arr[i + 1]:
        is_sorted = False
        first_violation = i + 1
        break

if is_sorted:
    print("YES")
else:
    print("NO", first_violation)
```

---

## Тема 2: Работа со строками

### Задача 2.1: Подсчет вхождений подстроки
Даны две строки S и T. Подсчитайте, сколько раз строка T входит в строку S (пересекающиеся вхождения считаются отдельно).

**Формат ввода:**
- Первая строка: S
- Вторая строка: T
- Строки содержат только маленькие латинские буквы, длины не превышают 10000

**Формат вывода:**
Количество вхождений

**Пример:**
```
Ввод:
abababa
aba
Вывод:
3
```

**Вопросы для проверки:**
1. Какой алгоритм поиска подстроки вы использовали?
2. Какова временная сложность вашего решения?
3. Можно ли использовать KMP алгоритм для этой задачи?
4. В чем разница между пересекающимися и непересекающимися вхождениями?

**Ответы на вопросы:**
1. Для небольших строк можно использовать наивный алгоритм (проверка всех позиций). Для больших строк лучше использовать KMP или Z-функцию.
2. Наивный алгоритм: O(n*m), где n - длина S, m - длина T. KMP алгоритм: O(n + m).
3. Да, KMP алгоритм отлично подходит и более эффективен для больших строк. Он позволяет находить все вхождения за один проход.
4. Пересекающиеся вхождения могут начинаться на соседних позициях (например, "aba" в "abababa" на позициях 0, 2, 4). Непересекающиеся вхождения требуют, чтобы между ними было расстояние не меньше длины подстроки.

**Пример решения:**
```python
s = input()
t = input()

count = 0
n = len(s)
m = len(t)

# Наивный алгоритм: проверяем все возможные позиции
for i in range(n - m + 1):
    if s[i:i+m] == t:
        count += 1

print(count)
```

---

### Задача 2.2: Проверка на палиндром
Проверьте, является ли строка палиндромом (читается одинаково слева направо и справа налево).

**Формат ввода:**
- Одна строка (длина не превышает 1000)

**Формат вывода:**
"YES" или "NO"

**Пример:**
```
Ввод:
racecar
Вывод:
YES

Ввод:
hello
Вывод:
NO
```

**Вопросы для проверки:**
1. Какова временная сложность вашего решения?
2. Можно ли решить за O(1) дополнительной памяти?
3. Как бы вы модифицировали решение для игнорирования пробелов и регистра?
4. Какова сложность решения с использованием реверса строки?

**Ответы на вопросы:**
1. Временная сложность O(n), где n - длина строки. Нужно проверить половину строки.
2. Да, можно использовать два указателя (слева и справа) и сравнивать символы без создания дополнительных строк. Это O(1) дополнительной памяти.
3. Нужно предварительно обработать строку: удалить пробелы и привести к одному регистру, либо проверять символы с пропуском пробелов и сравнением без учета регистра.
4. Реверс строки и сравнение также O(n) по времени, но требует O(n) дополнительной памяти для новой строки.

**Пример решения:**
```python
s = input().strip()

# Метод 1: сравнение с реверсом
if s == s[::-1]:
    print("YES")
else:
    print("NO")

# Метод 2: два указателя (более эффективен по памяти)
# left, right = 0, len(s) - 1
# is_palindrome = True
# while left < right:
#     if s[left] != s[right]:
#         is_palindrome = False
#         break
#     left += 1
#     right -= 1
# print("YES" if is_palindrome else "NO")
```

---

### Задача 2.3: Проверка на анаграмму
Даны две строки. Проверьте, являются ли они анаграммами (содержат одинаковые символы в разном порядке).

**Формат ввода:**
- Первая строка: S1
- Вторая строка: S2
- Длины строк не превышают 1000

**Формат вывода:**
"YES" или "NO"

**Пример:**
```
Ввод:
listen
silent
Вывод:
YES

Ввод:
hello
world
Вывод:
NO
```

**Вопросы для проверки:**
1. Какой алгоритм вы использовали для проверки?
2. Какова временная сложность?
3. Можно ли решить без сортировки?
4. Как бы вы модифицировали решение для учета регистра?

**Ответы на вопросы:**
1. Можно использовать сортировку обеих строк и сравнение, либо подсчет частот символов с помощью словаря/массива.
2. Сортировка: O(n log n), где n - длина строк. Подсчет частот: O(n).
3. Да, можно использовать подсчет частот символов. Создать словарь или массив из 26 элементов (для латинских букв) и подсчитать вхождения каждого символа в обеих строках.
4. Для учета регистра нужно либо привести обе строки к одному регистру перед проверкой, либо использовать отдельные счетчики для заглавных и строчных букв.

**Пример решения:**
```python
s1 = input()
s2 = input()

# Метод 1: сортировка
if sorted(s1) == sorted(s2):
    print("YES")
else:
    print("NO")

# Метод 2: подсчет частот (более эффективен)
# from collections import Counter
# if Counter(s1) == Counter(s2):
#     print("YES")
# else:
#     print("NO")
```

---

## Тема 3: Стек и скобочные последовательности

### Задача 3.1: Проверка правильности скобок
Дана строка, содержащая только символы '(', ')', '[', ']'. Проверьте, является ли она правильной скобочной последовательностью.

**Формат ввода:**
- Одна строка (длина не превышает 1000)

**Формат вывода:**
"YES" или "NO"

**Пример:**
```
Ввод:
([()])
Вывод:
YES

Ввод:
([)]
Вывод:
NO
```

**Вопросы для проверки:**
1. Какую структуру данных вы использовали?
2. Какова временная сложность?
3. Как вы обрабатываете несоответствие типов скобок?
4. Что произойдет, если строка содержит другие символы?

**Ответы на вопросы:**
1. Используется стек (stack) для хранения открывающих скобок. При встрече закрывающей скобки проверяется соответствие с последней открывающей в стеке.
2. Временная сложность O(n), где n - длина строки. Каждый символ обрабатывается один раз.
3. При встрече закрывающей скобки проверяем, что стек не пуст и последняя открывающая скобка соответствует типу закрывающей. Если нет - последовательность неправильная.
4. Если строка содержит другие символы, их нужно игнорировать или считать ошибкой в зависимости от условия задачи. В данной задаче предполагается, что других символов нет.

**Пример решения:**
```python
s = input()
stack = []
pairs = {')': '(', ']': '['}

for char in s:
    if char in '([':
        stack.append(char)
    elif char in ')]':
        if not stack or stack[-1] != pairs[char]:
            print("NO")
            exit(0)
        stack.pop()

if len(stack) == 0:
    print("YES")
else:
    print("NO")
```

---

### Задача 3.2: Минимальное количество удалений для ПСП
Дана строка из круглых скобок. Найдите минимальное количество символов, которое нужно удалить, чтобы получить правильную скобочную последовательность.

**Формат ввода:**
- Одна строка, содержащая только '(' и ')'
- Длина не превышает 1000

**Формат вывода:**
Минимальное количество удалений

**Пример:**
```
Ввод:
())(()
Вывод:
2
```

**Вопросы для проверки:**
1. Как вы определяете, какие скобки нужно удалить?
2. Какова сложность вашего решения?
3. Можно ли решить за один проход?
4. Как бы вы модифицировали решение для вывода самой длинной правильной подпоследовательности?

**Ответы на вопросы:**
1. Используем счетчик: открывающие скобки увеличивают счетчик, закрывающие уменьшают. Если счетчик отрицательный, закрывающая скобка лишняя. В конце оставшиеся открывающие скобки (положительный счетчик) также лишние.
2. Сложность O(n) - один проход по строке.
3. Да, можно решить за один проход с помощью счетчика открывающих/закрывающих скобок.
4. Для вывода самой длинной правильной подпоследовательности нужно использовать динамическое программирование или стек для отслеживания правильных пар.

**Пример решения:**
```python
s = input()
count = 0  # счетчик открывающих скобок
removals = 0  # количество удалений

for char in s:
    if char == '(':
        count += 1
    else:  # char == ')'
        if count > 0:
            count -= 1  # нашли пару
        else:
            removals += 1  # лишняя закрывающая скобка

# Все оставшиеся открывающие скобки тоже нужно удалить
removals += count

print(removals)
```

---

### Задача 3.3: Максимальная глубина вложенности
Дана правильная скобочная последовательность. Найдите максимальную глубину вложенности скобок.

**Формат ввода:**
- Одна строка из круглых скобок
- Длина не превышает 1000

**Формат вывода:**
Максимальная глубина

**Пример:**
```
Ввод:
((())(()))
Вывод:
3
```

**Вопросы для проверки:**
1. Как вы отслеживаете текущую глубину?
2. Какова сложность алгоритма?
3. Можно ли решить без стека?
4. Как бы вы модифицировали решение для нескольких типов скобок?

**Ответы на вопросы:**
1. Используем счетчик: при открывающей скобке увеличиваем счетчик и обновляем максимум, при закрывающей уменьшаем счетчик.
2. Сложность O(n) - один проход по строке.
3. Да, можно решить без стека, используя только счетчик, так как последовательность правильная и нам не нужно проверять соответствие скобок.
4. Для нескольких типов скобок нужно использовать стек для отслеживания типов скобок, но логика подсчета глубины остается аналогичной.

**Пример решения:**
```python
s = input()
depth = 0
max_depth = 0

for char in s:
    if char == '(':
        depth += 1
        max_depth = max(max_depth, depth)
    else:  # char == ')'
        depth -= 1

print(max_depth)
```

---

## Тема 4: Стек и ближайшие элементы

### Задача 4.1: Ближайший больший элемент справа
Для каждого элемента массива найдите ближайший больший элемент справа. Если такого нет, выведите -1.

**Формат ввода:**
- Первая строка: N (1 ≤ N ≤ 1000)
- Вторая строка: N целых чисел

**Формат вывода:**
N чисел - ближайшие большие элементы

**Пример:**
```
Ввод:
5
4 5 2 10 8
Вывод:
5 10 10 -1 -1
```

**Вопросы для проверки:**
1. Какую структуру данных вы использовали?
2. Какова временная сложность?
3. В чем разница между ближайшим большим и ближайшим меньшим?
4. Можно ли решить за один проход?

**Ответы на вопросы:**
1. Используется монотонный стек (monotonic stack) - стек, который поддерживает монотонное убывание элементов. Элементы извлекаются из стека, когда находится больший элемент.
2. Временная сложность O(n) - каждый элемент добавляется и извлекается из стека максимум один раз.
3. Для ближайшего большего используем монотонно убывающий стек, для ближайшего меньшего - монотонно возрастающий стек. Логика обратная.
4. Да, можно решить за один проход справа налево или слева направо с использованием стека.

**Пример решения:**
```python
n = int(input())
arr = list(map(int, input().split()))
result = [-1] * n
stack = []

# Проходим справа налево
for i in range(n - 1, -1, -1):
    # Удаляем из стека элементы, меньшие или равные текущему
    while stack and stack[-1] <= arr[i]:
        stack.pop()
    
    # Если стек не пуст, берем верхний элемент
    if stack:
        result[i] = stack[-1]
    
    # Добавляем текущий элемент в стек
    stack.append(arr[i])

print(' '.join(map(str, result)))
```

---

### Задача 4.2: Ближайший меньший элемент слева
Для каждого элемента массива найдите ближайший меньший элемент слева. Если такого нет, выведите -1.

**Формат ввода:**
- Первая строка: N (1 ≤ N ≤ 1000)
- Вторая строка: N целых чисел

**Формат вывода:**
N чисел - ближайшие меньшие элементы слева

**Пример:**
```
Ввод:
5
4 5 2 10 8
Вывод:
-1 4 -1 2 2
```

**Вопросы для проверки:**
1. Как вы модифицируете алгоритм для поиска слева?
2. Какова сложность решения?
3. Можно ли использовать тот же подход, что и для справа?
4. Как бы вы решили задачу для ближайшего большего слева?

**Ответы на вопросы:**
1. Проходим слева направо и используем монотонно возрастающий стек (элементы в стеке должны быть строго меньше текущего).
2. Сложность O(n) - каждый элемент обрабатывается один раз.
3. Да, тот же подход с монотонным стеком, но направление обхода меняется, и условие сравнения инвертируется.
4. Для ближайшего большего слева используем монотонно убывающий стек и проходим слева направо, аналогично задаче 4.1, но в обратном направлении.

**Пример решения:**
```python
n = int(input())
arr = list(map(int, input().split()))
result = [-1] * n
stack = []

# Проходим слева направо
for i in range(n):
    # Удаляем из стека элементы, большие или равные текущему
    while stack and stack[-1] >= arr[i]:
        stack.pop()
    
    # Если стек не пуст, берем верхний элемент
    if stack:
        result[i] = stack[-1]
    
    # Добавляем текущий элемент в стек
    stack.append(arr[i])

print(' '.join(map(str, result)))
```

---

### Задача 4.3: Максимальная площадь под гистограммой
Дан массив высот столбцов гистограммы. Найдите максимальную площадь прямоугольника, который можно вписать под гистограмму.

**Формат ввода:**
- Первая строка: N (1 ≤ N ≤ 1000)
- Вторая строка: N целых положительных чисел (высоты)

**Формат вывода:**
Максимальная площадь

**Пример:**
```
Ввод:
6
2 1 5 6 2 3
Вывод:
10
(прямоугольник высотой 5 и шириной 2)
```

**Вопросы для проверки:**
1. Как вы используете стек для решения этой задачи?
2. Какова временная сложность?
3. Как вы определяете границы прямоугольника?
4. Можно ли решить без стека?

**Ответы на вопросы:**
1. Используем монотонно возрастающий стек. Для каждого столбца находим ближайшие меньшие столбцы слева и справа, что определяет ширину прямоугольника с высотой текущего столбца.
2. Временная сложность O(n) - каждый элемент добавляется и извлекается из стека максимум один раз.
3. Границы определяются позициями ближайших меньших элементов слева и справа. Ширина = right - left - 1, площадь = высота * ширина.
4. Теоретически можно решить без стека за O(n²), перебирая все возможные прямоугольники, но это неэффективно. Стек дает оптимальное решение O(n).

**Пример решения:**
```python
n = int(input())
heights = list(map(int, input().split()))

max_area = 0
stack = []  # стек индексов

for i in range(n):
    # Удаляем из стека элементы, пока текущий элемент меньше
    while stack and heights[stack[-1]] > heights[i]:
        height = heights[stack.pop()]
        # Ширина определяется текущей позицией и предыдущей в стеке
        width = i if not stack else i - stack[-1] - 1
        max_area = max(max_area, height * width)
    
    stack.append(i)

# Обрабатываем оставшиеся элементы в стеке
while stack:
    height = heights[stack.pop()]
    width = n if not stack else n - stack[-1] - 1
    max_area = max(max_area, height * width)

print(max_area)
```
