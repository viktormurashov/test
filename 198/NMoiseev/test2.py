#1 Поиск подстроки
# Алгоритм: Наивный поиск подстроки (Naive String Matching)
# Сложность: O(n*m), где n - длина строки S, m - длина подстроки T
# Для больших строк (до 50000) лучше использовать KMP или Z-алгоритм (O(n+m)),
# но для данных ограничений текущий алгоритм может быть приемлемым

s1 = "aaaaa"
t1 = "aaa"

res = []
# Перебираем все возможные позиции начала подстроки в строке
# Последняя позиция: len(s1) - len(t1), так как после неё не поместится подстрока
for i in range(len(s1) - len(t1) + 1):
    # Проверяем, совпадает ли подстрока начиная с позиции i с искомой подстрокой
    if s1[i:i+len(t1)] == t1:
        res.append(i)

print(' '.join(map(str, res)))

#2 Циклический сдвиг
# Алгоритм: Проверка всех возможных циклических сдвигов
# Сложность: O(n^2), где n - длина строки
# Для каждой позиции k проверяем, совпадает ли сдвиг s2[k:] + s2[:k] с t2
# Можно оптимизировать до O(n) используя алгоритм поиска подстроки (KMP)

s2 = "питон"
t2 = "нотип"

# Если длины не совпадают, циклический сдвиг невозможен
if len(s2) != len(t2):
    print(-1)
else:
    ans = -1
    # Перебираем все возможные сдвиги от 0 до len(s2)-1
    # k - количество позиций сдвига вправо
    for k in range(len(s2)):
        # s2[k:] - часть строки от позиции k до конца
        # s2[:k] - часть строки от начала до позиции k
        # Конкатенация даёт строку, сдвинутую на k позиций вправо
        if s2[k:] + s2[:k] == t2:
            ans = k
            break  # Нашли минимальный сдвиг, можно прекратить поиск
    print(ans)