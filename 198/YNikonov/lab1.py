# ============================================================================
# РЕВЬЮ КОДА: КРИТИЧЕСКИЕ ОШИБКИ И АНАЛИЗ
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА: bubble модифицирует исходный список in-place
# Последствие: исходный список будет изменен после вызова функции
# Решение: создать копию списка перед сортировкой или внутри функции
# ============================================================================
# АЛГОРИТМ: реализован КОРРЕКТНО
# Логика правильная, сложность O(n^2)
# ============================================================================
# ПРИЗНАКИ ИСПОЛЬЗОВАНИЯ LLM:
# - Стандартная учебная реализация
# - Тестовые данные захардкожены в коде
# - Отсутствие структуры if __name__ == "__main__"
# ============================================================================

def bubble(x):  # 1.1 Bubble sort
    if len(x) <= 1:
        return x

    for i in range(len(x) - 1):
        for j in range(len(x) - 1 - i):
            if x[j] > x[j + 1]:
                x[j], x[j + 1] = x[j + 1], x[j]
    return x


test = [1, 6, 2, 5, 9, 3, 5, 3, 6, 7, 4, 8, 1]
print(bubble(test))


# ============================================================================
# РЕВЬЮ: merge_sort реализован КОРРЕКТНО
# Алгоритм правильный, сложность O(n log n)
# Использует `<=` для стабильности сортировки (хорошая практика)
# ============================================================================
# ЗАМЕЧАНИЕ: опечатка в комментарии "Megre" вместо "Merge" (строка 16)
# ============================================================================
# ПРИЗНАКИ LLM: стандартная реализация, захардкоженные тестовые данные
# ============================================================================

def merge_sort(x):  # 1.2 Megre sort
    if len(x) <= 1:
        return x

    mid = len(x) // 2
    left = merge_sort(x[:mid])
    right = merge_sort(x[mid:])

    return merge(left, right)


def merge(l, r):
    result = []
    i = j = 0

    while len(l) > i and len(r) > j:
        if l[i] <= r[j]:
            result.append(l[i])
            i += 1
        else:
            result.append(r[j])
            j += 1

    result.extend(l[i:])
    result.extend(r[j:])

    return result


test = [1, 6, 2, 5, 9, 3, 5, 3, 6, 7, 4, 8, 1]
print(merge_sort(test))

# ============================================================================
# РЕВЬЮ: quick реализован КОРРЕКТНО, но НЕЭФФЕКТИВНО
# Алгоритм правильный, сложность O(n log n) в среднем
# ============================================================================
# ПОЛОЖИТЕЛЬНЫЙ МОМЕНТ: использует random.choice для выбора pivot
# Это помогает избежать худшего случая O(n^2) при отсортированных данных
# ============================================================================
# КРИТИЧЕСКАЯ ПРОБЛЕМА ПРОИЗВОДИТЕЛЬНОСТИ: создает новые списки на каждом уровне
# Сложность по памяти O(n log n) вместо O(log n) для классического Quick Sort
# Не является in-place алгоритмом
# ============================================================================
# ПРОБЛЕМА: import random в середине файла (строка 48)
# Импорты должны быть в начале файла согласно PEP 8
# ============================================================================
# ПРИЗНАКИ LLM: стандартная реализация, захардкоженные тестовые данные
# ============================================================================

import random

def quick(x):  # 1.3 Quick sort
    if len(x) <= 1:
        return x
    piv = random.choice(x)
    l = [i for i in x if i < piv]
    m = [i for i in x if i == piv]
    r = [i for i in x if i > piv]

    return quick(l) + m + quick(r)


test = [1, 6, 2, 5, 9, 3, 5, 3, 6, 7, 4, 8, 1]
print(quick(test))
