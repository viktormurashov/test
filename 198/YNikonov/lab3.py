# ============================================================================
# РЕВЬЮ КОДА: ЗАДАЧА 3.1 - Получение ПСП
# ============================================================================
# АЛГОРИТМ: реализован КОРРЕКТНО
# Логика правильная: считаем баланс открывающих скобок, удаляем лишние
# Алгоритм эффективный, сложность O(n)
# ============================================================================
# ВСЕ СООТВЕТСТВУЕТ ЗАДАНИЮ: формат вывода правильный (только число)
# ============================================================================
# ПРИЗНАКИ LLM: стандартная реализация, краткий код
# ============================================================================

st = input()  # 3.1 Получение ПСП
rem = 0
opened = 0

for s in st:
    if s == "(":
        opened += 1
    else:
        if opened > 0:
            opened -= 1
        else:
            rem += 1

rem += opened

print(rem)


# ============================================================================
# РЕВЬЮ КОДА: ЗАДАЧА 3.2 - Ближайший меньший
# ============================================================================
# АЛГОРИТМ: реализован КОРРЕКТНО и ОПТИМАЛЬНО!
# Использует стек для решения за O(n) - отличный подход!
# Это классический алгоритм "Next Smaller Element" со стеком
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА: неправильный формат вывода
# По заданию: "выведите" числа через пробел (например: "-1 4 3 4 -1...")
# Текущий код: print(res) выводит список [-1, 4, 3, 4, -1, ...]
# Правильно: print(' '.join(map(str, res))) для вывода через пробел
# ============================================================================
# ПОЛОЖИТЕЛЬНЫЙ МОМЕНТ: использование стека показывает понимание алгоритмов
# Это более продвинутое решение, чем наивный O(n^2) подход
# ============================================================================
# ПРИЗНАКИ LLM: оптимальный алгоритм (может быть из LLM или хорошего источника)
# Но несоответствие формату вывода указывает на LLM
# ============================================================================

n = int(input())  # 3.2 Ближайший меньший

a = input().split()
arr = [int(x) for x in a]

res = [-1] * n
stack = []

for i in range(n):
    while stack and arr[i] < arr[stack[-1]]:
        res[stack.pop()] = i
    stack.append(i)

print(res)
