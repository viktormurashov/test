INF = 10**9
N, M = map(int, input().split())                   # Чтение входных данных: N - количество вершин, M - количество рёбер
dist = [[INF] * (N + 1) for _ in range(N + 1)]

for i in range(1, N + 1):                          # Заполнение главной диагонали: расстояние от вершины до самой себя равно 0
    dist[i][i] = 0

for _ in range(M):                                 # Чтение информации о рёбрах графа
    u, v, w = map(int, input().split())            # u, v - вершины, w - вес ребра
    dist[u][v] = dist[v][u] = min(dist[u][v], w)   # Используем min на случай, если между вершинами несколько рёбер


# Поиск кратчайших путей между всеми парами вершин
for k in range(1, N + 1):                          # промежуточная вершина
    for i in range(1, N + 1):                      # начальная вершина
        for j in range(1, N + 1):                  # конечная вершина
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) # Обновляем расстояние через промежуточную вершину k


# Поиск вершины с минимальным эксцентриситетом
# Эксцентриситет вершины - максимальное расстояние от неё до других вершин
best_vertex = 1                                    # начальное предположение - первая вершина
min_eccentricity = max(dist[1][1:])                # эксцентриситет первой вершины

for i in range(2, N + 1):                          # Проверяем все остальные вершины
    eccentricity = max(dist[i][1:])                # вычисляем эксцентриситет текущей вершины

    if eccentricity < min_eccentricity:           # Если нашли вершину с меньшим эксцентриситетом, обновляем результат
        min_eccentricity = eccentricity
        best_vertex = i

print(best_vertex)






