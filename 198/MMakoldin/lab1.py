# ============================================================================
# РЕВЬЮ КОДА: КРИТИЧЕСКИЕ ОШИБКИ И АНАЛИЗ
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА #1: bubble_sort модифицирует исходный список in-place
# Последствие: исходный список будет изменен после вызова функции
# Решение: создать копию списка перед сортировкой (см. AY\lab1.py строка 3)
# ============================================================================
# ПРИЗНАКИ ИСПОЛЬЗОВАНИЯ LLM:
# - Избыточно подробные комментарии на русском языке
# - Стандартная учебная реализация без оптимизаций
# - Отсутствие обработки edge cases (пустой список, один элемент)
# - Тестовые данные захардкожены в коде
# ============================================================================

def bubble_sort(obj):
    n = len(obj)
    
    # Проходим по списку n раз
    for i in range(n):
        for j in range(n - i - 1):

            if obj[j] > obj[j + 1]: #сравнение значений

                obj[j], obj[j+1] = obj[j+1], obj[j] #замена, если условие выполняется

    return obj


# ============================================================================
# РЕВЬЮ: ОТСУТСТВУЕТ ОБРАБОТКА ВВОДА/ВЫВОДА
# По заданию требуется работа с входными данными, а не захардкоженные тесты
# ============================================================================

s_val = bubble_sort([5, 1, 4, 2, 8])
print(s_val)

# ============================================================================
# РЕВЬЮ: merge_sort реализован КОРРЕКТНО
# Алгоритм правильный, сложность O(n log n)
# ============================================================================
# ПРИЗНАКИ LLM: подробные пошаговые комментарии, типичные для генерации кода
# ============================================================================

def merge_sort(obj):
    # если список пуст или содержит один элемент, он уже отсортирован
    if len(obj) <= 1:
        return obj

    # если нет - делим список на две половины
    mid = len(obj) // 2
    left_half = obj[:mid]
    right_half = obj[mid:]

    # рекурсивно сортируем каждую половину
    left_sorted = merge_sort(left_half)
    right_sorted = merge_sort(right_half)

    # объединяем отсортированные половины
    return merge(left_sorted, right_sorted)

def merge(left, right):
    result = []
    i = j = 0

    # сравниваем элементы из left и right и добавляем меньший в result
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # если в left или right остались элементы, добавляем их в конец
    while i < len(left):
        result.append(left[i])
        i += 1
        
    while j < len(right):
        result.append(right[j])
        j += 1

    return result

# ============================================================================
# РЕВЬЮ: тестовые данные захардкожены (типично для LLM-сгенерированного кода)
# ============================================================================

my_list = [38, 27, 43, 3, 9, 82, 10, 11, 4]

sorted_list = merge_sort(my_list)
print(sorted_list)

# ============================================================================
# РЕВЬЮ: quick_sort реализован КОРРЕКТНО, но НЕЭФФЕКТИВНО
# КРИТИЧЕСКАЯ ПРОБЛЕМА ПРОИЗВОДИТЕЛЬНОСТИ:
# - Создает новые списки на каждом уровне рекурсии (O(n) дополнительной памяти)
# - Не является in-place алгоритмом, как классический Quick Sort
# - Для больших данных может привести к проблемам с памятью
# Алгоритм работает правильно, но сложность по памяти O(n log n) вместо O(log n)
# ============================================================================
# ПРИЗНАКИ LLM: закомментированные print-ы (типично для отладки сгенерированного кода)
# ============================================================================

def quick_sort(obj):
    if len(obj) <= 1:
        return obj
    
    # поиск среднего элемента
    mid_elem = obj[len(obj) // 2]
    # print(mid_elem)
    # группы
    left = [x for x in obj if x < mid_elem]
    middle = [x for x in obj if x == mid_elem]
    right = [x for x in obj if x > mid_elem]
    # print(left, middle, right)
    # сортируем левую и правую части, объединяем с серединой
    return quick_sort(left) + middle + quick_sort(right)


my_list = [64, 34, 25, 12, 22, 11, 90, 15]

sorted_list = quick_sort(my_list)
print(sorted_list)
