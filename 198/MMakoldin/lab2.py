# ============================================================================
# РЕВЬЮ КОДА: КРИТИЧЕСКИЕ ОШИБКИ И АНАЛИЗ
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА #1: ПЕРЕПУТАНЫ ПАРАМЕТРЫ!
# По заданию: найти индексы вхождений T в S
# Но функция ищет val_s в val_t (наоборот!)
# Правильно: find_index(S, T) должна искать T в S
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА #2: возвращает None вместо пустого списка
# Последствие: при вызове print() выведет "None" вместо "[]" или пустой строки
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА #3: range(0, len(val_t)+1) - лишняя итерация
# Правильно: range(0, len(val_t) - s_len + 1)
# Текущий код может выйти за границы при слайсинге
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА #4: формат вывода не соответствует заданию
# По заданию: "В порядке возрастания выведите все индексы" через пробел
# Текущий код возвращает список, который выведется как [0, 5, 7]
# Нужно: "0 5 7" (через пробел)
# ============================================================================
# ПРОБЛЕМА ПРОИЗВОДИТЕЛЬНОСТИ: O(n*m) наивный алгоритм
# Для строк до 50000 символов может быть медленным
# Рекомендуется алгоритм KMP или хотя бы оптимизация
# ============================================================================
# ПРИЗНАКИ ИСПОЛЬЗОВАНИЯ LLM:
# - Избыточная валидация (isalpha, islower) - по заданию вход всегда корректен
# - Неоптимальный алгоритм без оптимизаций
# - Смешение логики валидации и алгоритма
# ============================================================================

def find_index(val_t, val_s):
    
    s_len = len(val_s)
    res_indexes = []

    if len(val_s) > len(val_t): #если val_s больше val_t, то нет смысла пытаться искать вхождения
        return None
    
    if len(val_t) > 50000 or s_len > 50000:
        raise ValueError("По условию: длины строк - натуральные числа, не превосходящие 50000")
    
    if not val_t.isalpha() or not val_t.islower() or not val_s.isalpha() or not val_s.islower():
        raise ValueError("Строка должна содержать только маленькие латинские буквы")
    
    for value in range(0, len(val_t)+1):
        if val_s == val_t[value: value + s_len]:
            res_indexes.append(value)
    return res_indexes


# ============================================================================
# РЕВЬЮ: неправильный порядок ввода
# По заданию: первая строка - S, вторая строка - T
# Текущий код: сначала T, потом S (наоборот!)
# ============================================================================
# РЕВЬЮ: отладочные print-ы в основном коде (типично для LLM)
# ============================================================================

val_t = input("Введите строку T:")

print('val_t', val_t, len(val_t))

val_s = input("Введите строку S")
print('val_s', val_s, len(val_s))

val_s_indexes = find_index(val_t, val_s)

print(val_s_indexes)

# ============================================================================
# РЕВЬЮ: КРИТИЧЕСКИЕ ОШИБКИ В cycle_d
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА #1: возвращает строку '-1' вместо числа -1
# По заданию: "вывести минимальный возможный размер сдвига вправо или -1"
# Текущий код: return '-1' (строка)
# Правильно: return -1 (число)
# ============================================================================
# КРИТИЧЕСКАЯ ОШИБКА #2: неправильное направление сдвига!
# val_s[k:] + val_s[:k] - это сдвиг ВЛЕВО на k позиций
# По заданию нужен сдвиг ВПРАВО
# Пример: S="zabcd", сдвиг вправо на 1 -> "dzabc"
# Текущий код: val_s[1:] + val_s[:1] = "abcd" + "z" = "abcdz" (сдвиг влево!)
# Правильно для сдвига вправо: val_s[-k:] + val_s[:-k] или val_s[len(val_s)-k:] + val_s[:len(val_s)-k]
# ============================================================================
# ПРОБЛЕМА ПРОИЗВОДИТЕЛЬНОСТИ: создает новую строку на каждой итерации O(n)
# Для строк до 50000 символов это O(n^2) операций
# Можно оптимизировать через двойную строку: (val_s + val_s)[k:k+len(val_s)]
# ============================================================================
# ПРОБЛЕМА: неиспользуемая переменная res_indexes
# ============================================================================
# ПРИЗНАКИ LLM: избыточная валидация, неоптимальный алгоритм
# ============================================================================

def cycle_d(val_t, val_s):
    s_len = len(val_s)
    res_indexes = []

    if len(val_s) > len(val_t) or len(val_t) > len(val_s):
        raise ValueError("Строки должны быть одинаковой длинны")

    if len(val_t) > 50000 or s_len > 50000:
        raise ValueError("По условию: длины строк - натуральные числа, не превосходящие 50000")
    
    if not val_t.isalpha() or not val_t.islower() or not val_s.isalpha() or not val_s.islower():
        raise ValueError("Строка должна содержать только маленькие латинские буквы")

    for k in range(len(val_t)):
        t = val_s[k:] + val_s[:k] #сдвиг на k символов

        if t == val_t:
            return k

    return '-1' # в случае, если строка T НЕ является циклическим строки S

# ============================================================================
# РЕВЬЮ: закомментированный input, захардкоженные данные (типично для LLM)
# РЕВЬЮ: отладочные print-ы в основном коде
# РЕВЬЮ: неправильный порядок параметров (должно быть S, потом T)
# ============================================================================

val_t = 'zabcd'
# input("Введите строку T:")

print('val_t', val_t, len(val_t))

val_s = 'abcdz'
# input("Введите строку S")
print('val_s', val_s, len(val_s))

val_s_indexes = cycle_d(val_t, val_s)

print(val_s_indexes)